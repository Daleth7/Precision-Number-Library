#ifndef PRECISION_STRICT_SERIES_CLASS_DEFINITION__H__
#define PRECISION_STRICT_SERIES_CLASS_DEFINITION__H__

#include "General_Base/Precision_Tags.h"
#include "Precision_Sequence.h"

#include <vector>

/*
    Precision::StrictSequence is a container specifically designed
    for a set of numbers generated by a given generator.
    This generator shall take at least one parameter: the
    index, that is, n in the set [a_0, ... a_n].
    The numbers in StrictSequence are guaranteed not to changed and
    follow a fixed pattern. For a series whose elements may be
    edited and whose pattern is not fixed, use Precision::Sequence.
    Precision::StrictSequence shall follow the rules of the STL
    containers with the exception that no elements may be
    inserted nor removed from the series.
*/

#define SS_INST_ StrictSequence<NumberType, Container, GeneratorType>

namespace Precision{
    template <
        typename NumberType,
        template <typename...> class Container = std::vector,
        typename GeneratorType = NumberType(std::size_t)
    >
    class StrictSequence : Tag::Set{
        public:
        //Type Aliases
            using unrestricted_type = Sequence<
                                        NumberType,
                                        Container,
                                        GeneratorType
                                    >;
            using size_type         = typename unrestricted_type::size_type;
            using value_type        = typename unrestricted_type::value_type;
            using reference         = typename unrestricted_type::reference;
            using const_reference   = typename unrestricted_type::const_reference;
            using pointer           = typename unrestricted_type::pointer;
            using const_pointer     = typename unrestricted_type::const_pointer;
            using difference_type   = typename unrestricted_type::difference_type;
            using container_type    = typename unrestricted_type::container_type;
            using generator_type    = typename unrestricted_type::generator_type;

        //Read-only
            bool empty()const
                {return m_base.empty();}

            size_type size()const
                {return m_base.size();}

            const_reference operator[](size_type n)const
                {return m_base.at(n);}

            const_reference at(size_type n)const
                {return m_base.at(n);}

            size_type first_index()const
                {return m_base.first_index();}

            size_type last_index()const
                {return m_base.last_index();}

            const generator_type& generator()const
                {return m_base.generator();}

            const_reference front()const
                {return m_base.front();}

            const_reference back()const
                {return m_base.back();}

            SS_INST_ subseries(size_type start, size_type stop=0)const{
                SS_INST_ toreturn;
                toreturn.m_base = m_base.subseries(start, stop);
                return toreturn;
            }

            value_type sum(size_type start = 0, size_type stop = 0)const
                {return m_base.sum(start, stop);}

            value_type product(size_type start = 0, size_type stop = 0)const
                {return m_base.product(start, stop);}

            short compare(const SS_INST_& s)const
                {return m_base.compare(s.m_base);}

            size_type max_size()const
                {return m_base.max_size();}

        //Modifiers
            void pop_front(size_type num = 1)
                {m_base.pop_front(num);}

            void pop_back(size_type num = 1)
                {m_base.pop_back(num);}

            void generate(size_type num = 1)
                {m_base.generate(num);}

            void resize(size_type new_size)
                {m_base.resize(new_size);}

            void clear()
                {m_base.clear();}

            void swap(SS_INST_& s)
                {m_base.swap(s.m_base);}

        //Iterators
            using const_iterator
                = typename unrestricted_type::const_iterator;
            using const_reverse_iterator
                = typename unrestricted_type::const_reverse_iterator;

            const_iterator begin()const
                {return m_base.cbegin();}

            const_iterator end()const
                {return m_base.cend();}

            const_reverse_iterator rbegin()const
                {return m_base.crbegin();}

            const_reverse_iterator rend()const
                {return m_base.crend();}

            const_iterator cbegin()const
                {return m_base.cbegin();}

            const_iterator cend()const
                {return m_base.cend();}

            const_reverse_iterator crbegin()const
                {return m_base.crbegin();}

            const_reverse_iterator crend()const
                {return m_base.crend();}

            const_iterator find(const_reference val)const
                {return m_base.cfind(val);}

            const_iterator cfind(const_reference val)const
                {return m_base.cfind(val);}


        //Constructors and destructor
            StrictSequence(
                const generator_type& new_gen,
                size_type start = 0,
                size_type stop = 0
            )
                : m_base(new_gen, start, stop)
            {}
            StrictSequence(const SS_INST_&)               = default;
            StrictSequence(SS_INST_&&)                    = default;
            StrictSequence& operator=(const SS_INST_&)    = default;
            StrictSequence& operator=(SS_INST_&&)         = default;
            ~StrictSequence()                             = default;
        private:
            unrestricted_type m_base;
    };
}

#undef SS_INST_

#endif
