<!DOCTYPE HTML>
<HTML>
    <HEAD>
		<STYLE>
            @import url("../../doc_style.css");
            <LINK rel="stylesheet" type="text/css" href="doc_style.css">
		</STYLE>
    </HEAD>
    <BODY>
        <H2>Precision::General_Base::Random
            <FONT SIZE=2><SUB>(<FONT COLOR="#FF0000">template</FONT>)
            </SUB></FONT></H2>
        <P>
            A psuedo-random number generator whose number type may be varied.
            The current implementation of this system only works with integral
            types, or types that support logical operations such as shifting and
            AND'ing.
            <BR />
            <BR />
            <FONT SIZE=2>
                Associated File: <B><A
                    href="../../../../General_Base/Precision_Random_General_Base.h"
                >Precision/General_Base/Precision_Random_General_Base.h</A></B>
            </FONT>
            <BR />
            <UL>
                <LI><A href="#Template">Template Parameter Information</A></LI>
                <LI><A href="#Interface">Class Interface Information</A></LI>
                <LI><A href="#Example">Example Use</A></LI>
            </UL>
            <BR />
        </P>
        <TABLE WIDTH=90% id="Template">
            <TR>
                <TH WIDTH=33%>Template Parameter</TH>
                <TH>Description</TH>
            </TR>
            <TR>
                <TD><I>typename IntegerType</I></TD>
                <TD>
                    An integral type used by the generator. It is of this type
                    that numbers are generated.
                </TD>
            </TR>
        </TABLE>
            <BR />
        <TABLE WIDTH=90% id="Interface">
            <TR>
                <TH>Namespace</TH>
                <TH>Class</TH>
                <TH>Category</TH>
                <TH>Member</TH>
            </TR>
            <TR>
                <TD ROWSPAN=20>General_Base</TD>
                <TD ROWSPAN=20>Random&lt;IntegerType></TD>
                <TD>Types</TD>
                <TD>
                    <DL>
                        <DT><I>type</I></DT>
                        <DD>
                            The type used and generated by the functor. This is
                            a type alias for <I>IntegerType</I>.
                        </DD>
                        <DT><I>lli</I></DT>
                        <DD>
                            The primitive, signed integral type that serves
                            as the unit of order of entropy.
                        </DD>
                        <DT><I>size_type</I></DT>
                        <DD>
                            The primitive, unsigned integral type that serves
                            as the unit of a counting system, such as
                            determining size of using indices.
                        </DD>
                        <DT><I>digit_10_type</I></DT>
                        <DD>
                            The type of the object returned when calling
                            <I>base()</I>. Otherwise, this type is not used.
                        </DD>
                    </DL>
                </TD>
            </TR>
            <TR>
                <TD>Read Only</TD>
                <TD>
                    <DL>

                    <DT id="seed"><I>const type& seed()const</I></DT>
                    <DD>
                        Returns the current seed used by the generator.
                        The returned value may be equivalent to the value
                        last returned by a call to <I>operator()()</I>.
                    </DD>
            <BR />
                    <DT id="max"><I>const type& max()const</I></DT>
                    <DD>
                        Returns the maximum possible value the functor
                        may generate.
                    </DD>
            <BR />
                    <DT id="min"><I>const type& min()const</I></DT>
                    <DD>
                        Returns the minimum possible value the functor
                        may generate.
                    </DD>
            <BR />
                    <DT id="and1"><I>const type& and1()const</I></DT>
                    <DT id="and2"><I>const type& and2()const</I></DT>
                    <DT id="and3"><I>const type& and3()const</I></DT>
                    <DT id="and4"><I>const type& and4()const</I></DT>
                    <DD>
                        Returns one of four control values that aid in
                        randomizing each digit.
                    </DD>
            <BR />
                    <DT id="ooe"><I>lli order_of_entropy()const</I></DT>
                    <DD>Returns a signed integer representing the order
                        of entropy the functor is set to.</DD>
            <BR />
                    <DT id="push1"><I>size_type push1()const</I></DT>
                    <DT id="push2"><I>size_type push2()const</I></DT>
                    <DT id="push3"><I>size_type push3()const</I></DT>
                    <DD>
                        Returns one of three control values that help refresh
                        the generated value.
                    </DD>
            <BR />
                    <DT id="base"><I>static digit_10_type base()</I></DT>
                    <DD>Returns the number base of <I>type</I>.</DD>
                    </DL>
                </TD>
            </TR>
            <TR>
                <TD>State modifiers</TD>
                <TD>
                    <DL>
                    <DT id="operator_functor"><I>type operator()()</I></DT>
                    <DD>Returns a randomly generated number.</DD>
            <BR />
                    <DT id="discard"><I>Random& discard()</I></DT>
                    <DD>
                        Advance one state without returning the generated number.
                        This is as if calling <I>operator()()</I> but not using
                        the value returned. The functor itself is returned via
                        reference to allow for function chaining.
                    </DD>
                    </DL>
                </TD>
            </TR>
            <TR>
                <TD>Setting modifiers</TD>
                <TD>
                    <DL>
                    <DT id="seed_mod"><I>Random& seed(const type& new_seed)</I></DT>
                    <DD>
                        Set a new seed for the generator. A reference to the
                        functor is returned for function chaining.
                    </DD>
            <BR />
                    <DT id="max_mod"><I>Random& max(const type& new_max)</I></DT>
                    <DD>
                        Set a new maximum that the generator may produce. A
                        reference to the functor is returned for function
                        chaining.
                    </DD>
            <BR />
                    <DT id="min_mod"><I>Random& min(const type& new_min)</I></DT>
                    <DD>
                        Set a new minimum that the generator may produce. A
                        reference to the functor is returned for function
                        chaining.
                    </DD>
            <BR />
                    <DT id="and1_mod"><I>Random& and1(const type& new_and1)</I></DT>
                    <DT id="and2_mod"><I>Random& and2(const type& new_and2)</I></DT>
                    <DT id="and3_mod"><I>Random& and3(const type& new_and3)</I></DT>
                    <DT id="and4_mod"><I>Random& and4(const type& new_and4)</I></DT>
                    <DD>
                        Change one of four control values that help randomize
                        each digit. A reference to the functor is returned for
                        function chaining.
                    </DD>
            <BR />
                    <DT id="ooe_mod"><I>Random& order_of_entropy(lli)</I></DT>
                    <DD>
                        Change the order of entropy the functor is set to. The
                        higher the order, the more random the numbers generated
                        will be but the more slower the generator will become.
                        The vice versa is true as well.
                    </DD>
            <BR />
                    <DT id="push1_mod"><I>Random& push1(size_type new_push1)</I></DT>
                    <DT id="push2_mod"><I>Random& push2(size_type new_push2)</I></DT>
                    <DT id="push3_mod"><I>Random& push3(size_type new_push3)</I></DT>
                    <DD>
                        Change one of three control values that aid in refreshing
                        the generated number, i.e. increase the period of the
                        pattern before it repeats.
                    </DD>
                    </DL>
                </TD>
            </TR>
            <TR>
                <TD>Constructors and destructor</TD>
                <TD>
                    <DL>
                    <DT id="construct"><I>
                        Random(
                        <BLOCKQUOTE>
                            const type& INseed = 1,
            <BR />
                            const type& INmax = Helper::rand_wrapper&lt;type,
                                typename
                                std::is_fundamental&lt;type>::type>::max(),
            <BR />
                            const type& INmin = 0,
            <BR />
                            bool call_discard = true,
            <BR />
                            lli INorder_of_entropy = -5,
            <BR />
                            const type& INand1 = 0xBFFFFFF6,
            <BR />
                            const type& INand2 = 0xBFFAFFFF,
            <BR />
                            const type& INand3 = 0xDDFECB7F,
            <BR />
                            const type& INand4 = 0xDFFFFFEF,
            <BR />
                            size_type INpush1 = 8,
            <BR />
                            size_type INpush2 = 11,
            <BR />
                            size_type INpush3 = 18
                        </BLOCKQUOTE>
                        )
                    </I></DT>
                    <DD>
                        Construct a new <I>Random</I> object with a list of
                        settings as described in member functions above. In
                        particular, the parameter <I>call_discard</I>, if
                        true, will cause the generator to discard states
                        after construction until the maximum number of digits
                        is reached. This is similar to "warming" up the generator.
            <BR />
            <BR />
                        <B>Note:</B> The first four parameters: <I>INseed,
                        INmax, INmin, call_discard</I>; are the more important
                        parameters. The rest are for further customization of
                        how the generator should behave.
                    </DD>
                    </DL>
            <BR />
                The copy/move constructors and assigners are compiler generated.
                The destructor is compiler generated as well.
                </TD>
            </TR>
        </TABLE>
            <BR />
        <TABLE STYLE="border-collapse:collapse;" ID="Example">
        <CAPTION>Example Use</CAPTION><TR><TD><OL><CODE>
        <LI>#include &lt;iostream></LI>
        <LI>#include &lt;ctime></LI>
        <LI>#include "Precision.h"</LI>
        <LI></LI>
        <LI>int main(){</LI>
        <LI>&nbsp;&nbsp;&nbsp;&nbsp;using namespace Precision;</LI>
        <LI></LI>
        <LI>&nbsp;&nbsp;&nbsp;&nbsp;typedef General_Base::Random&lt;UInt> Rand_Type;</LI>
        <LI></LI>
        <LI>//Constructor</LI>
        <LI>&nbsp;&nbsp;&nbsp;&nbsp;Rand_Type rand(std::time(nullptr)); //Seed</LI>
        <LI></LI>
        <LI>//Read Only</LI>
        <LI>&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; "Current settings:\n";</LI>
        <LI>&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; "\tSeed: " &lt;&lt; rand.seed().str() &lt;&lt; '\n';</LI>
        <LI>&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; "\tMax: " &lt;&lt; rand.max().str() &lt;&lt; '\n';</LI>
        <LI>&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; "\tMin: " &lt;&lt; rand.min().str() &lt;&lt; '\n';</LI>
        <LI>&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; "\tAnd 1: " &lt;&lt; rand.and1().str() &lt;&lt; '\n';</LI>
        <LI>&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; "\tAnd 2: " &lt;&lt; rand.and2().str() &lt;&lt; '\n';</LI>
        <LI>&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; "\tAnd 3: " &lt;&lt; rand.and3().str() &lt;&lt; '\n';</LI>
        <LI>&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; "\tAnd 4: " &lt;&lt; rand.and4().str() &lt;&lt; '\n';</LI>
        <LI>&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; "\tOrder of entropy: " &lt;&lt; rand.order_of_entropy() &lt;&lt; '\n';</LI>
        <LI>&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; "\tPush 1: " &lt;&lt; rand.push1() &lt;&lt; '\n';</LI>
        <LI>&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; "\tPush 2: " &lt;&lt; rand.push2() &lt;&lt; '\n';</LI>
        <LI>&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; "\tPush 3: " &lt;&lt; rand.push3() &lt;&lt; '\n';</LI>
        <LI>&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; "\tBase (immutable): " &lt;&lt; Rand_Type::base() &lt;&lt; '\n';</LI>
        <LI></LI>
        <LI>//Setting Modifiers</LI>
        <LI>&nbsp;&nbsp;&nbsp;&nbsp;rand.seed(std::time(nullptr));</LI>
        <LI>&nbsp;&nbsp;&nbsp;&nbsp;rand.max(Rand_Type::type(1).logical_shift_left(50));</LI>
        <LI>&nbsp;&nbsp;&nbsp;&nbsp;rand.min(1000000);</LI>
        <LI>&nbsp;&nbsp;&nbsp;&nbsp;rand.and1(0x12EFD);</LI>
        <LI>&nbsp;&nbsp;&nbsp;&nbsp;rand.and2(0xFFFFFFF);</LI>
        <LI>&nbsp;&nbsp;&nbsp;&nbsp;rand.and3(0x0001000);</LI>
        <LI>&nbsp;&nbsp;&nbsp;&nbsp;rand.and4(0x1F50ABC);</LI>
        <LI>&nbsp;&nbsp;&nbsp;&nbsp;rand.order_of_entropy(3);</LI>
        <LI>&nbsp;&nbsp;&nbsp;&nbsp;rand.push1(5);</LI>
        <LI>&nbsp;&nbsp;&nbsp;&nbsp;rand.push2(10);</LI>
        <LI>&nbsp;&nbsp;&nbsp;&nbsp;rand.push3(7);</LI>
        <LI></LI>
        <LI>//State modifiers</LI>
        <LI>&nbsp;&nbsp;&nbsp;&nbsp;for(unsigned short i(0); i &lt; 5; ++i); //Discard first five states</LI>
        <LI>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rand.discard();</LI>
        <LI>&nbsp;&nbsp;&nbsp;&nbsp;for(unsigned short i(0); i &lt; 100; ++i); //Generate 100 numbers</LI>
        <LI>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; (i+1) &lt;&lt; ": " &lt;&lt; rand().str() &lt;&lt; '\n';</LI>
        <LI></LI>
        <LI>&nbsp;&nbsp;&nbsp;&nbsp;return 0;</LI>
        <LI>}</LI>
        </CODE></OL></TD></TR></TABLE>
    </BODY>
</HTML>