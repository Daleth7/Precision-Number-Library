<!DOCTYPE HTML>
<HTML>
    <HEAD>
		<STYLE>
            @import url("../../doc_style.css");
            <LINK rel="stylesheet" type="text/css" href="doc_style.css">
		</STYLE>
    </HEAD>
    <BODY>
        <H2>Precision::General_Base::Fract
            <FONT SIZE=2><SUB>(<FONT COLOR="#FF0000">template</FONT>)
            </SUB></FONT></H2>
        <P>
            A class template for signed, fractional numbers of unlimited
            size and precision. This class also remembers a precision for
            times when the number must be converted to a floating point
            type. In addition, the objects auto-simplify when necessary.
            <BR />
            <B>Note</B>: The numerator and denominator shall be integral
            values.
            <BR />
            <BR />
            <FONT SIZE=2>
                Associated File: <B><A
                    href="../../../General_Base/Precision_Fract_General_Base.h"
                >Precision/General_Base/Precision_Fract_General_Base.h</A></B>
            </FONT>
            <BR />
            <UL>
                <LI><A href="#template">Template Parameter Information</A></LI>
                <LI><A href="#interface">Class Interface Information</A></LI>
                <LI><A href="#example">Example Use</A></LI>
            </UL>
            <BR />
        </P>
        <TABLE WIDTH=90% id="template">
            <TR>
                <TH WIDTH=33%>Template Parameter</TH>
                <TH>Description</TH>
            </TR>
            <TR>
                <TD><I>typename CharT</I></TD>
                <TD>
                    The type of character or image used to represent each digit
                    in Base N. Must be compatible as a template parameter to
                    <I>std::basic_string&lt;T></I>. The string type
                    (<I>str_type</I>) of the class shall be instantiated as
                    <I>std::basic_string&lt;CharT></I>. The following or the 
                    equivalent of the following functions must be supported
                    for type <I>CharT</I>:
                    <UL STYLE="font-style:italic;">
                        <LI>std::istream& operator>>(std::istream&, CharT&)</LI>
                        <LI>bool operator==(const CharT&, const CharT&)</LI>
                    </UL>
                </TD>
            </TR>
            <TR>
                <TD><I>CharT const *const _0</I></TD>
                <TD>
                    A pointer to the first digit in an array containing the
                    images of each digit. The array must have external
                    linkage.
            <BR />
                    <B>Note</B>: It is the responsibility of the
                    instantiator to ensure <I>_0</I> is a valid parameter and
                    that the array pointed to contains the appropriate images.
                </TD>
            </TR>
            <TR>
                <TD><I>typename ByteType</I></TD>
                <TD>
                    The type used for the computer representation of each
                    digit. This type also sets the maximum base that may
                    be used and affects the dynamic storage size. Defaulted
                    to <I>Precision::byte_type</I>, which is guaranteed to
                    allow a base up to 64 and is guaranteed to be at
                    least one byte in size. It is recommended to use
                    <I>Precision::byte_type</I> for small bases.
                </TD>
            </TR>
            <TR>
                <TD><I>ByteType Base</I></TD>
                <TD>
                    The base N the class shall represent. Defaulted to 10.
            <BR />
                    <B>Note</B>: The behaviour of the instantiation is not
                    guaranteed if the base is below 2.
                </TD>
            </TR>
            <TR>
                <TD><I>CharT const *const _symbols</I></TD>
                <TD>
                    A pointer to the first symbol in an array with external
                    linkage and that contains the images of each symbol.
                    Each symbol is further defined below in the order it
                    should appear in the array.
                    <UL>
                        <LI><I>plus symbol</I></LI>
                        <UL>
                            <LI>
                                An image depicting the plus sign to indicate a
                                positive number as in "+123".
                            </LI>
                        </UL>
                        <LI><I>minus symbol</I></LI>
                        <UL>
                            <LI>
                                An image depicting the minus sign to indicate a
                                negative number as in "-123".
                            </LI>
                        </UL>
                        <LI><I>point symbol</I></LI>
                        <UL>
                            <LI>
                                An image depicting the decimal point to indicate a
                                separation between a number's whole part and
                                decimal part as in "123.456".
                            </LI>
                        </UL>
                        <LI><I>exponent symbol</I></LI>
                        <UL>
                            <LI>
                                An image depicting the exponential sign to
                                represent a power of 10 as in "1.23 E 456"
                                which is equivalent to writing "1.23 *
                                10<SUP>456</SUP>".
                            </LI>
                        </UL>
                        <LI><I>space symbol</I></LI>
                        <UL>
                            <LI>
                                An image depicting an empty space between two
                                other images as in "+ 1234".
                            </LI>
                        </UL>
                    </UL>
                    The above five symbols are required as the minimum.
                    Depending on what the number type is tagged with from
                    <I>Precision::Tag</I>, there may be additional symbols
                    needed.
                    <UL>
                        <LI><I>slash symbol</I></LI>
                        <UL>
                            <LI>
                                An image depicting the slash sign to indicate a
                                fractional number as in "12/345". Required for
                                fraction number types, tagged with
                                <I>Tag::Fraction</I>.
                            </LI>
                        </UL>
                        <LI><I>imaginary symbol</I></LI>
                        <UL>
                            <LI>
                                An image depicting the imaginary number to
                                indicate a complex number as in "a + bi".
                                Required for complex number types, tagged with
                                <I>Tag::Complex</I>.
                            </LI>
                        </UL>
                    </UL>
                    <I>_symbols</I> is defaulted to <I>Constant::symbols</I>
                    which points to an array containing images of type
                    <I>const char</I>:
                    <TABLE STYLE="text-align:center;">
                        <TR><TD>plus symbol</TD><TD WIDTH=15%>+</TD></TR>
                        <TR><TD>minus symbol</TD><TD>-</TD></TR>
                        <TR><TD>point symbol</TD><TD>.</TD></TR>
                        <TR><TD>exponent symbol</TD><TD>E</TD></TR>
                        <TR><TD>space symbol</TD><TD> </TD></TR>
                        <TR><TD>slash symbol</TD><TD>/</TD></TR>
                        <TR><TD>imaginary symbol</TD><TD>i</TD></TR>
                    </TABLE>
                    <B>Note</B>: It is the responsibility of the
                    instantiator to ensure <I>_symbols</I> is a valid parameter
                    and that the array pointed to contains the appropriate
                    symbols.
                </TD>
            </TR>
            <TR>
                <TD><I>typename &lt;template...> Container</I></TD>
                <TD>
                    The container used to store indices to the array.
                    Most STL containers will work. The type must support
                    the following:
                    <UL STYLE="font-style:italic;">
                        <LI>Container::Container(size_type, digit_type)</LI>
                        <LI>At minimum: bidirectional iterators</LI>
                        <LI>Container::begin()</LI>
                        <LI>Container::end()</LI>
                        <LI>Container::crbegin()</LI>
                        <LI>Container::crend()</LI>
                        <LI>Container::push_back()</LI>
                        <LI>Container::size()</LI>
                        <LI>Container::insert(iterator, size_type, digit_type)</LI>
                        <LI>Container::erase(iterator, size_type)</LI>
                        <LI>Container::erase(iterator)</LI>
                    </UL>
                    Defaulted to <I>Precision::default_container_type</I>.
                </TD>
            </TR>
            <TR>
                <TD><I>typename SignType</I></TD>
                <TD>
                    The type used to represent the sign of the number, i.e.
                    whether it is positive or negative. The type must support
                    the following:
                    <UL STYLE="font-style:italic;">
                        <LI>signed_integral_type SignType::value()const</LI>
                        <LI>bool SignType::positive()const</LI>
                        <LI>bool SignType::negative()const</LI>
                        <LI>void SignType::negate()</LI>
                        <LI>void SignType::make_positive()</LI>
                        <LI>void SignType::make_negative()</LI>
                        <LI>SignType::SignType(sign_integral_type)</LI>
                    </UL>
                    By convention, all number types in the Precision namespace
                    shall abide by the following rules:
                    <UL>
                        <LI>signed short(1) == positive</LI>
                        <LI>signed short(-1) == negative</LI>
                    </UL>
                    Defaulted to <I>Precision::SignClass</I>.
                </TD>
            </TR>
        </TABLE>
            <BR />
        <TABLE WIDTH=90% id="interface">
            <TR>
                <TH>Namespace</TH>
                <TH>Class</TH>
                <TH>Category</TH>
                <TH>Member</TH>
            </TR>
            <TR>
                <TD ROWSPAN=6>General_Base</TD>
                <TD ROWSPAN=6>Fract&lt;CharT, _0, ByteType, Base,
                    _symbols, Container, SignType></TD>
                <TD>Types</TD>
                <TD>
                    <DL>
                        <DT><I ID="Integer_t">Integer</I></DT>
                        <DD>
                            While this class is the fraction version,
                            <I>Integer</I> represents the whole number version.
                            When calling methods such as <I>integer()</I>, an
                            object of this type is returned. This type is
                            equivalent to
                            <I><A href="Precision_Int_General_Base.html">
                            Precision::General_Base::Int</A></I>.
                        </DD>
                        <DT ID="Floating"><I>Floating</I></DT>
                        <DD>
                            The floating point number version that is returned
                            when calling methods such as <I>decimal()</I>. This
                            type is equivalent to
                            <I><A href="Precision_Float_General_Base.html">
                            Precision::General_Base::Float</A></I>.
                        </DD>
                        <DT ID="str_type"><I>str_type</I></DT>
                        <DD>
                            The type which represents a string of CharT objects.
                            It is used to display the number. <I>str_type</I> is
                            equivalent to <I>std::basic_string&lt;CharT></I>.
                        </DD>
                        <DT ID="lli"><I>lli</I></DT>
                        <DD>
                            A primitive type that represents a signed, integral
                            number with a wide range. The client need not worry
                            about this type.
                        </DD>
                        <DT ID="ld"><I>ld</I></DT>
                        <DD>
                            A primitive type that represents a signed, floating
                            point number with a wide range and large precision.
                            The client need not worry about this type.
                        </DD>
                        <DT ID="image_type"><I>image_type</I></DT>
                        <DD>
                            A type whose objects represent the visual display
                            of each digit. This type is equivalent to
                            <I>CharT</I>.
                        </DD>
                        <DT ID="digit_type"><I>digit_type</I></DT>
                        <DD>
                            A type whose objects are the computer representations
                            of each digit. This type is equivalent to
                            <I>ByteType</I>.
                        </DD>
                        <DT ID="diglist_type"><I>diglist_type</I></DT>
                        <DD>
                            A container that stores each digit of the number.
                            This type is equivalent to
                            <I>Container&lt;CharT></I>. For the most part, the
                            client need not worry about this type.
                        </DD>
                        <DT ID="sign_type"><I>sign_type</I></DT>
                        <DD>
                            The type whose objects represent positive and
                            negative. This type is equivalent to <I>SignType</I>.
                            For the most part, the client need not worry about
                            this type.
                        </DD>
                        <DT ID="size_type"><I>size_type</I></DT>
                        <DD>
                            A type whose objects represent a counting system such
                            as when checking size or using indices. This type is
                            equivalent to <I>std::size_t</I>.
                        </DD>
                    </DL>
                </TD>
            </TR>
            <TR>
                <TD>Read only</TD>
                <TD>
                    <DL>
                    <DT ID="sign">sign_type sign()const</DT>
                    <DD>
                        Return an object that represents what sign the number
                        is, i.e. positive or negative.
                    </DD>
            <BR />
                    <DT ID="str">str_type str()const</DT>
                    <DD>Return the visual display of the number as a string.</DD>
            <BR />
                    <DT ID="mixed">str_type mixed()const</DT>
                    <DD>Similar to <I>str()</I> but this function formats
                        the number in its mixed form, that is, a whole number
                        followed by a proper fraction.</DD>
            <BR />
                    <DT ID="magnitude">Fract magnitude()const</DT>
                    <DD>
                        Return the absolute value of the number, or the
                        distance between 0 and the number.
                    </DD>
            <BR />
                    <DT ID="precision">size_type precision()const</DT>
                    <DD>Return the precision of the number.</DD>
            <BR />
                    <DT ID="compare">short compare(const Fract& s)const</DT>
                    <DD>
                        Return a code number representing how the number
                        compares to the parameter, i.e. it will be as if
                        [This number] [Code] [Parameter].
                        The code will be as follows:
                        <UL>
                            <LI>1: Greater than</LI>
                            <LI>0: Equal to</LI>
                            <LI>-1: Less than</LI>
                        </UL>
                    </DD>
            <BR />
                    <DT ID="whole">Integer whole()const</DT>
                    <DT ID="integer">Integer integer()const</DT>
                    <DD>
                        Return the whole part of the number, e.g.
            <BR />
                        <CODE>Fract("-23/4").integer()
                            == Fract::Integer("-5")</CODE>
                    </DD>
            <BR />
                    <DT ID="floating_point">Floating
                        floating_point()const</DT>
                    <DT ID="decimal">Floating decimal()const</DT>
                    <DD>
                        Return the number in its floating point form, i.e.
                        as if the numerator was divided by the denominator.
                        The precision remembered by the object shall also
                        be used in constructing the floating point number.
                    </DD>
            <BR />
                    <DT ID="gcd">Integer gcd(const Fract& s)const</DT>
                    <DD>Return the Greatest Common Denominator of this number
                        and the parameter.</DD>
            <BR />
                    <DT ID="op_negate">Fract operator-()const</DT>
                    <DD>Return the negated version of the number.</DD>
            <BR />
                    <DT ID="op_complement">Fract operator~()const</DT>
                    <DD>
                        <B>Note</B>: This is not the bitwise complement operator.
            <BR />
                        Return a copy of the number inverted, as if
                        calling <I>inverse()</I>.
                    </DD>
            <BR />
                    <DT ID="even">bool even()const</DT>
                    <DD>
                        Check if the number is even, i.e. if the number is a
                        multiple of 2. This will check the rightmost digit
                        as if calling <CODE>decimal().digit_10(0)</CODE>.
                    </DD>
            <BR />
                    <DT ID="odd">bool odd()const</DT>
                    <DD>
                        Check if the number is odd, i.e. if the number is not
                        a multiple of 2. This will check the rightmost digit
                        as if calling <CODE>decimal().digit_10(0)</CODE>.
                    </DD>
            <BR />
                    <DT ID="positive">bool positive()const</DT>
                    <DD>
                        Check if the number is positive, i.e. if the number is
                        greater than 0.
                    </DD>
            <BR />
                    <DT ID="negative">bool negative()const</DT>
                    <DD>
                        Check if the number is negative, i.e. if the number is
                        less than 0.
                    </DD>
            <BR />
                    <DT ID="numerator">Integer numerator()const</DT>
                    <DD>Return the numerator, or the
                        top number of the fraction.</DD>
            <BR />
                    <DT ID="denominator">Integer denominator()const</DT>
                    <DD>Return the denominator, or the
                        bottom number of the fraction.</DD>
            <BR />
                    <DT ID="remainder">Fract
                        remainder(const Fract& s)const</DT>
                    <DD>
                        Return the remainder of dividing this number by the
                        parameter.
                    </DD>
            <BR />
                    <DT ID="inverse">Fract inverse()const</DT>
                    <DD>
                        Return a copy of this number inverted. This is as if
                        dividing 1 by this number, or <CODE>1/[This]</CODE>.
                    </DD>
            <BR />
                    <DT ID="is_integer">bool is_integer()const</DT>
                    <DD>
                        Return whether or not this number could be considered
                        whole. This is true if:
            <BR />
                        <CODE>[This].numerator()
                            % [This].denominator() == 0</CODE>
                    </DD>
            <BR />
                    <DT ID="digit">image_type digit(size_type index)const</DT>
                    <DD>
                        Obtain one of the digits of the number in its floating
                        point form, the returned value in its visual
                        representation. The parameter, <I>index</I>, is relative
                        to the rightmost digit, e.g.
                        <CODE>calling digit(0)</CODE> on the number "12/5"
                        with a precision of 1 will return "4".
                    </DD>
            <BR />
                    <DT ID="digit_10">digit_type
                        digit_10(size_type index)const</DT>
                    <DD>
                        Similar to <I>digit(size_type)</I> but returns the digit
                        in its computer representation, which will inevitably
                        be shown as base 10.
                    </DD>
            <BR />
                    <DT ID="base">static digit_type base()</DT>
                    <DD>
                        Return, in base 10, the number base of the number type.
                        This will effectively return <I>Base</I>.
                    </DD>
            <BR />
                    <DT ID="digit0">static image_type const* digit0()</DT>
                    <DD>
                        Return a pointer to the array used by the number type.
                        The array will contain the visual symbols that represent
                        each digit. This will effectively return <I>_0</I>.
                    </DD>
                    </DL>
                </TD>
            </TR>
            <TR>
                <TD>Modifiers</TD>
                <TD>
                    <DL>
                    <DT ID="precision_mod">void
                        precision(size_type new_precision)</DT>
                    <DD>
                        Change the precision the number remembers. This is
                        possible since the number only uses the precision
                        when constructing its floating point form.
                    </DD>
            <BR />
                    <DT ID="numerator_mod">void
                        numerator(const Integer& new_numerator)</DT>
                        <DD>Replace the old numerator with the new one.</DD>
            <BR />
                    <DT ID="denominator">void
                        denominator(const Integer& new_denominator)</DT>
                    <DD>
                        Replace the old denominator with the new one.
            <BR />
                        <B>Note</B>: Attempting to assign 0 as the new
                        denominator shall cause a <I>division_by_zero</I>
                        error to be thrown.
                    </DD>
            <BR />
                    <DT ID="shift">void shift(lli count)</DT>
                    <DD>
                        Multiply the number by an order of magnitude of
                        <I>Base</I>. This effectively multiplies the number
                        by <I>Base<SUP>count</SUP></I>.
                    </DD>
            <BR />
                    <DT ID="shift_left">void shift_left(size_type count)</DT>
                    <DD>
                        Similar to <I>shift(lli)</I> where the behaviour is
                        effectively <I>Base<SUP>count</SUP></I>.
                    </DD>
            <BR />
                    <DT ID="shift_right">void shift_right(size_type count)</DT>
                    <DD>
                        Similar to <I>shift(lli)</I> where the behaviour is
                        effectively <I>Base<SUP>-count</SUP></I>.
                    </DD>
            <BR />
                    <DT ID="sign_mod">void sign(sign_type new_sign)</DT>
                    <DD>Assign a new sign for the number.</DD>
            <BR />
                    <DT ID="negate">void negate()</DT>
                    <DD>
                        Reverse the sign of the number. This is similar to
                        calling <I>operator-()</I>, except the number is
                        modified.
                    </DD>
            <BR />
                    <DT ID="exponentiate">Fract&
                        exponentiate(const Integer& s)</DT>
                    <DD>
                        Take the power of this number by the parameter and
                        store the result in this number. Return a reference
                        to this number to allow for function chaining.
                    </DD>
            <BR />
                    <DT ID="exponentatef">Fract& exponentiate(const Fract& s)</DT>
                    <DD>
                        Take the power of this number by the parameter and
                        store the result in this number. Return a reference
                        to this number to allow for function chaining. This
                        method is slower than the integer version due to the
                        different algorithm.
                    </DD>
            <BR />
                    <DT ID="invert">Fract& invert()</DT>
                    <DD>
                        Invert this number as if dividing 1 by this number,
                        i.e. <CODE>1/[This]</CODE>. Return a reference to this
                        number to allow for function chaining.
                    </DD>
            <BR />
                    <DT ID="swap">void swap(Fract& s)</DT>
                    <DD>Switch the values of this number and the parameter.</DD>
                    </DL>
                </TD>
            </TR>
            <TR>
                <TD>Arithmetic operators</TD>
                <TD>
                    <DL>
                    <DT ID="op_plus_eq">Fract& operator+=(const Fract& s)</DT>
                    <DD>
                        Add the parameter to this number and assign the sum
                        to this number. Return a reference to this number to
                        allow for function chaining.
                    </DD>
            <BR />
                    <DT ID="op_minus_eq">Fract& operator-=(const Fract& s)</DT>
                    <DD>
                        Subtract the parameter from this number and assign the
                        difference to this number. Return a reference to this
                        number to allow for function chaining.
                    </DD>
            <BR />
                    <DT ID="op_mult_eq">Fract& operator*=(const Fract& s)</DT>
                    <DD>
                        Multiply the parameter to this number and assign the
                        product to this number. Return a reference to this
                        number to allow for function chaining.
                    </DD>
            <BR />
                    <DT ID="op_divide_eq">Fract& operator/=(const Fract& s)</DT>
                    <DD>
                        Divide this number by the parameter and assign the
                        quotient to this number. Return a reference to this
                        number to allow for function chaining.
                    </DD>
            <BR />
                    <DT ID="op_mod_eq">Fract& operator%=(const Fract& s)</DT>
                    <DD>
                        <B>Note</B>: This is not the modulus operator.
            <BR /> 
                        Divide this number by the parameter and assign the
                        remainder to this number. Return a reference to this
                        number to allow for function chaining.
                    </DD>
            <BR />
                    <DT ID="op_exp_eq">Fract& operator^=(const Fract& s)</DT>
                    <DD>
                        <B>Note</B>: This is not the bitwise XOR operator.
            <BR />
                        Exponentiate this number by the parameter and assign
                        the result to this number. Return a reference to this
                        number to allow function chaining.
                    </DD>
            <BR />
                    <DT ID="op_pre_dec">Fract& operator--()</DT>
                    <DD>
                        Decrement this number by 1 and return a reference
                        to the result (this number).
                    </DD>
            <BR />
                    <DT ID="op_post_dec">Fract operator--(int)</DT>
                    <DD>Decrement this number by 1 but
                        return the original value.</DD>
            <BR />
                    <DT ID="op_pre_inc">Fract& operator++()</DT>
                    <DD>
                        Increment this number by 1 and return a reference
                        to the result (this number).
                    </DD>
            <BR />
                    <DT ID="op_post_inc">Fract operator++(int)</DT>
                    <DD>Increment this number by 1 but
                        return the original value.</DD>
                    </DL>
                </TD>
            </TR>
            <TR>
                <TD>Type casts</TD>
                <TD>
                    <DL>
                    <DT ID="cast_int">explicit
                        operator Integer()const</DT>
                    <DD>
                        Return the whole part of this number as
                        if calling <I>integer()</I>.
                    </DD>
            <BR />
                    <DT ID="cast_float">explicit operator
                        Floating()const</DT>
                    <DD>
                        Return the whole part of this number as
                        if calling <I>floating_point()</I>.
                    </DD>
                    </DL>
                </TD>
            </TR>
            <TR>
                <TD>Constructors and destructor</TD>
                <TD>
                    <DL>
                    <DT ID="con_default">Fract(ld new_number = 0.0,
                        size_type new_precision = k_default_prec)</DT>
                    <DD>
                        Construct a fraction from a floating point value and
                        remember the given precision, <I>new_precision</I>.
                    </DD>
            <BR />
                    <DT ID="con_str">Fract(const str_type& str,
                        size_type new_precision = k_default_prec)</DT>
                    <DD>
                        Construct an object from the visual representation of
                        the number and a set precision. This operation may be
                        slow since each digit has to be verified.
                    </DD>
            <BR />
                    <DT ID="con_int">Fract(const Integer& whole,
                        size_type new_precision = k_default_prec)</DT>
                    <DD>
                        Construct an object from an integral value and a set
                        precision. The denominator shall be set to 1.
                    </DD>
            <BR />
                    <DT ID="con_float">Fract(const Floating& whole)</DT>
                    <DD>
                        Construct an object from a floating point value. The
                        precision of the floating point value shall be
                        remembered by the constructed <I>Fract</I> object.
                    </DD>
            <BR />
                    <DT ID="con_int_int">Fract(const Integer& new_numerator,
                        const Integer& new_denominator,
                        size_type new_precision = k_default_prec)</DT>
                    <DD>Construct an object given the
                        numerator, denominator, and a set precision.</DD>
            <BR />
                    <DT ID="con_copy">Fract(const Fract&) = default</DT>
                        <DD>Compiler generated copy constructor.</DD>
            <BR />
                    <DT ID="con_move">Fract(Fract&&) = default</DT>
                        <DD>Compiler generated move constructor.</DD>
            <BR />
                    <DT ID="con_copy_eq">Fract&
                        operator=(const Fract&) = default</DT>
                        <DD>Compiler generated copy assignment operator.</DD>
            <BR />
                    <DT ID="con_move_eq">Fract&
                        operator=(Fract&&) = default</DT>
                        <DD>Compiler generated move assignment operator.</DD>
            <BR />
                    <DT ID="destruct">~Fract() = default</DT>
                        <DD>Compiler generated destructor.</DD>
                    </DL>
                </TD>
            </TR>
            <TR>
                <TD></TD>
                <TD></TD>
                <TD>Related non-members</TD>
                <TD>
                    <DL>
                    <DT ID="op_plus">Fract operator+(Fract, const Fract&)</DT>
                        <DD>Add the two parameters together.</DD>
            <BR />
                    <DT ID="op_minus">Fract operator-(Fract, const Fract&)</DT>
                        <DD>Find the difference of the two parameters.</DD>
            <BR />
                    <DT ID="op_mult">Fract operator*(Fract, const Fract&)</DT>
                        <DD>Multiply the two parameters together.</DD>
            <BR />
                    <DT ID="op_divide">Fract operator/(Fract, const Fract&)</DT>
                        <DD>Divide the the first parameter by the second.</DD>
            <BR />
                    <DT ID="op_mod">Fract operator%(Fract, const Fract&)</DT>
                        <DD>Find the remainder.</DD>
            <BR />
                    <DT ID="op_exp">Fract operator^(Fract, const Fract&)</DT>
                        <DD>Exponentiate the first parameter by the second.</DD>
            <BR />
                    <DT ID="op_is_eq">bool operator==(const Fract&, const Fract&)</DT>
                        <DD>Test if the two parameters are equal.</DD>
            <BR />
                    <DT ID="op_not_eq">bool operator!=(const Fract&, const Fract&)</DT>
                        <DD>Test if the two parameters are not equal.</DD>
            <BR />
                    <DT ID="op_geq">bool operator>=(const Fract&, const Fract&)</DT>
                    <DD>Test if the first parameter is
                        greater than or equal to the second.</DD>
            <BR />
                    <DT ID="op_leq">bool operator&lt;=(const Fract&, const Fract&)</DT>
                    <DD>Test if the first parameter is
                        less than or equal to the second.</DD>
            <BR />
                    <DT ID="op_g">bool operator>(const Fract&, const Fract&)</DT>
                    <DD>Test if the first parameter is
                        greater than the second.</DD>
            <BR />
                    <DT ID="op_l">bool operator&lt;(const Fract&, const Fract&)</DT>
                    <DD>Test if the first parameter is
                        less than the second.</DD>
            <BR />
                    <DT ID="op_not">bool operator!(const Fract&)</DT>
                        <DD>Test if the parameter is equal to 0.</DD>
                    </DL>
                </TD>
            </TR>
            <TR>
                <TD>Global</TD>
                <TD></TD>
                <TD>Related, global non-members</TD>
                <TD>
                    <DL>
                    <DT ID="g_swap">void swap(Precision::General_Base::Fract&,
                        Precision::General_Base::Fract&)
                        </DT>
                    <DD>Switch the value of the first
                            parameter with the second.</DD>
                    </DL>
                </TD>
            </TR>
        </TABLE>
            <BR />
        <TABLE STYLE="border-collapse:collapse;" ID="example">
        <CAPTION>Example Use</CAPTION><TR><TD><OL><CODE>
        <LI>#include "Precision.h"</LI>
        <LI></LI>
        <LI>#include &lt;iostream></LI>
        <LI></LI>
        <LI>&nbsp;&nbsp;&nbsp;&nbsp;// Using the base 10 instantiation</LI>
        <LI>int main(){</LI>
        <LI>&nbsp;&nbsp;&nbsp;&nbsp;using namespace Precision;</LI>
        <LI>&nbsp;&nbsp;&nbsp;&nbsp;using namespace std;</LI>
        <LI></LI>
        <LI>&nbsp;&nbsp;&nbsp;&nbsp;Fract testee(Int(-2830), Int(764));</LI>
        <LI></LI>
        <LI>&nbsp;&nbsp;&nbsp;&nbsp;cout &lt;&lt; boolalpha</LI>
        <LI>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt;
            testee.sign() &lt;&lt; '\n' // -1</LI>
        <LI>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt;
            testee.str() &lt;&lt; '\n' // -1415/382</LI>
        <LI>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt;
            testee.mixed() &lt;&lt; '\n' // -3 369/382</LI>
        <LI>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt;
            testee.magnitude().str() &lt;&lt; '\n' // +1415/382</LI>
        <LI>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt;
            testee.precision() &lt;&lt; '\n' // 100</LI>
        <LI>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt;
            testee.compare(1.7) &lt;&lt; '\n' // -1</LI>
        <LI>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt;
            testee.integer().str() &lt;&lt; '\n' // -3</LI>
        <LI>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt;
            testee.floating_point().str(5) &lt;&lt; '\n' // -3.70419</LI>
        <LI>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt;
            testee.gcd(Fract(Int(1), Int(764))).str() &lt;&lt; '\n' // +764</LI>
        <LI>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt;
            (-testee).str() &lt;&lt; '\n' // +1415/382</LI>
        <LI>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt;
            (~testee).str(10) &lt;&lt; '\n' // -382/1415</LI>
        <LI>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt;
            testee.even() &lt;&lt; '\n' // true</LI>
        <LI>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt;
            testee.odd() &lt;&lt; '\n' // false</LI>
        <LI>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt;
            testee.positive() &lt;&lt; '\n' // false</LI>
        <LI>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt;
            testee.negative() &lt;&lt; '\n' // true</LI>
        <LI>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt;
            testee.numerator().str() &lt;&lt; '\n' // -1415</LI>
        <LI>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt;
            testee.denominator().str() &lt;&lt; '\n' // +382</LI>
        <LI>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt;
            testee.is_integer() &lt;&lt; '\n' // false</LI>
        <LI>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt;
            testee.digit(100) &lt;&lt; '\n' // 7</LI>
        <LI>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt;
            testee.digit10(101) &lt;&lt; '\n' // 3</LI>
        <LI>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt;
            Fract::base() &lt;&lt; '\n' // 10</LI>
        <LI>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt;
            *Fract::digit0() &lt;&lt; '\n' // 0</LI>
        <LI>&nbsp;&nbsp;&nbsp;&nbsp;;</LI>
        <LI></LI>
        <LI>&nbsp;&nbsp;&nbsp;&nbsp;testee.shift(5);</LI>
        <LI>&nbsp;&nbsp;&nbsp;&nbsp;cout &lt;&lt; testee.str()
            &lt;&lt; '\n'; // -70750000/191</LI>
        <LI>&nbsp;&nbsp;&nbsp;&nbsp;testee.shift_left(3);</LI>
        <LI>&nbsp;&nbsp;&nbsp;&nbsp;cout &lt;&lt; testee.str()
            &lt;&lt; '\n'; // -70750000000/191</LI>
        <LI>&nbsp;&nbsp;&nbsp;&nbsp;testee.shift_right(10);</LI>
        <LI>&nbsp;&nbsp;&nbsp;&nbsp;cout &lt;&lt; testee.str()
            &lt;&lt; '\n'; // -283/7640</LI>
        <LI>&nbsp;&nbsp;&nbsp;&nbsp;testee.sign(1);</LI>
        <LI>&nbsp;&nbsp;&nbsp;&nbsp;cout &lt;&lt; testee.str()
            &lt;&lt; '\n'; // +283/7640</LI>
        <LI>&nbsp;&nbsp;&nbsp;&nbsp;testee.negate();</LI>
        <LI>&nbsp;&nbsp;&nbsp;&nbsp;cout &lt;&lt; testee.str()
            &lt;&lt; '\n'; // -283/7640</LI>
        <LI>&nbsp;&nbsp;&nbsp;&nbsp;Fract testee2("77/14");</LI>
        <LI>&nbsp;&nbsp;&nbsp;&nbsp;testee.swap(testee2);</LI>
        <LI>&nbsp;&nbsp;&nbsp;&nbsp;cout &lt;&lt; testee.str()
            &lt;&lt; '\n'; // +11/2</LI>
        <LI>&nbsp;&nbsp;&nbsp;&nbsp;cout &lt;&lt;
            (testee + testee2).str() &lt;&lt; '\n'; // +41737/7640</LI>
        <LI>&nbsp;&nbsp;&nbsp;&nbsp;cout &lt;&lt;
            (testee - testee2).str() &lt;&lt; '\n'; // +42303/7640</LI>
        <LI>&nbsp;&nbsp;&nbsp;&nbsp;cout &lt;&lt;
            (testee * testee2).str() &lt;&lt; '\n'; // -3113/15280</LI>
        <LI>&nbsp;&nbsp;&nbsp;&nbsp;cout &lt;&lt;
            (testee / testee2).str() &lt;&lt; '\n'; // -42020/283</LI>
        <LI>&nbsp;&nbsp;&nbsp;&nbsp;cout &lt;&lt;
            (testee % testee2).str() &lt;&lt; '\n'; // -136/283</LI>
        <LI>&nbsp;&nbsp;&nbsp;&nbsp;cout &lt;&lt;
            (++testee).str() &lt;&lt; '\n'; // +13/2</LI>
        <LI>&nbsp;&nbsp;&nbsp;&nbsp;cout &lt;&lt;
            (--testee).str() &lt;&lt; '\n'; // +11/2</LI>
        <LI>&nbsp;&nbsp;&nbsp;&nbsp;cout &lt;&lt;
            (testee++).str() &lt;&lt; '\n'; // +11/2</LI>
        <LI>&nbsp;&nbsp;&nbsp;&nbsp;cout &lt;&lt;
            (testee--).str() &lt;&lt; '\n'; // +13/2</LI>
        <LI></LI>
        <LI>&nbsp;&nbsp;&nbsp;&nbsp;return 0;</LI>
        <LI>}</LI>
        </CODE></OL></TD></TR></TABLE>
    </BODY>
</HTML>