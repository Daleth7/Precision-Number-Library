#ifndef PRECISION_SERIES_CLASS_DEFINITION__H__
#define PRECISION_SERIES_CLASS_DEFINITION__H__

#include "General_Base/Impl/Precision_Tags.h"

#include <vector>
#include <functional>

#define SEQ_INST_ Sequence<NumberType, Container, GeneratorType>

/*
    Precision::Sequence is a container specifically designed
    for a set of numbers generated by a given generator.
    This generator shall take at least one parameter: the
    index, that is, n in the set [a_0, ... a_n].
    Although the numbers shall be generated, they shall not
    be fixed, that is, the series does not guarantee all the
    numbers follow a pattern that can be regenerated by its
    generator algorithm. For a series whose pattern is fixed,
    use Precision::StrictSequence.
    Precision::Sequence shall follow the rules of the STL
    containers with the exception that no elements may be
    inserted nor removed from the series.
*/

namespace Precision{
    template <
        typename NumberType,
        template <typename...> class Container = std::vector,
        typename GeneratorType = NumberType(std::size_t)
    >
    class Sequence : Tag::Set{
        public:
        //Type Aliases
            using size_type         = std::size_t;
            using value_type        = NumberType;
            using reference         = value_type&;
            using const_reference   = const value_type&;
            using pointer           = value_type*;
            using const_pointer     = const value_type*;
            using difference_type   = std::ptrdiff_t;
            using container_type    = Container<value_type>;
            using generator_type    = std::function<GeneratorType>;

        //Read-only
            bool empty()const;
            size_type size()const;
            const_reference operator[](size_type n)const;
            const_reference at(size_type n)const;
            size_type first_index()const;
            size_type last_index()const;
            const generator_type& generator()const;
            const_reference front()const;
            const_reference back()const;
                //Any ranges will include only [start, stop)
            SEQ_INST_ subseries(size_type start, size_type stop=0)const;
            value_type sum(size_type start = 0, size_type stop = 0)const;
            value_type product(size_type start = 0, size_type stop = 0)const;
            short compare(const SEQ_INST_&)const;
            size_type max_size()const;

        //Modifiers
            void pop_front(size_type = 1);
            void pop_back(size_type = 1);
            void push_front(const value_type&, size_type = 1);
            void push_back(const value_type&, size_type = 1);
            void generate(size_type = 1);
            template <typename... ArgPack>
                void generate(size_type, ArgPack...);
            void resize(size_type);
            void clear();
            void swap(SEQ_INST_&);

            reference operator[](size_type n);
            void first_index(size_type);
            void last_index(size_type);
            void generator(const generator_type&);

        //Iterators
            using iterator          = typename container_type::iterator;
            using const_iterator    = typename container_type::const_iterator;
            using reverse_iterator  = typename container_type::reverse_iterator;
            using const_reverse_iterator
                = typename container_type::const_reverse_iterator;

            const_iterator begin()const;
            const_iterator end()const;
            const_reverse_iterator rbegin()const;
            const_reverse_iterator rend()const;
            const_iterator cbegin()const;
            const_iterator cend()const;
            const_reverse_iterator crbegin()const;
            const_reverse_iterator crend()const;

            const_iterator find(const_reference)const;
            const_iterator cfind(const_reference)const;

            iterator begin();
            iterator end();
            reverse_iterator rbegin();
            reverse_iterator rend();

            iterator find(const_reference);

        //Constructors and destructor
            Sequence(
                const generator_type&,
                size_type start = 0,
                size_type init_size = 0
            );
            template <typename Iter>
            Sequence(
                const Iter& start, const Iter& stop,
                const generator_type&,
                size_type start_index = 0
            );
            Sequence(const SEQ_INST_&)              = default;
            Sequence(SEQ_INST_&&)                   = default;
            Sequence& operator=(const SEQ_INST_&)   = default;
            Sequence& operator=(SEQ_INST_&&)        = default;
            ~Sequence()                             = default;
        protected:
            bool valid_index(size_type)const;
        private:
            size_type       m_start;
            generator_type  m_gen;
            container_type  m_series;
    };
}

#undef SEQ_INST_

#include "Precision_Sequence.inl"

#endif
