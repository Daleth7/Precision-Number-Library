#ifndef PRECISION_SERIES_CLASS_DEFINITION__H__
#define PRECISION_SERIES_CLASS_DEFINITION__H__

#include "General_Base/Precision_Tags.h"
#include "Precision_Sequence.h"

#define RSEQ_INST_ RecursiveSequence<NumberType, Container, GeneratorType>

/*
    Precision::RecursiveSequence is a container specifically
    designed for a set of numbers generated by a given
    generator. This generator shall take at least two
    parameters: the index, that is, n in the set
    [a_0, ... a_n] and a value equivalent to g(n-1) if g(n) is
    the generator function. Although the numbers shall be
    generated, they shall not be fixed, that is, the series
    does not guarantee all the numbers follow a pattern that
    can be regenerated by its generator algorithm. For a
    series whose pattern is fixed, use
    Precision::StrictRecursiveSequence.
    Precision::RecursiveSequence shall follow the rules of
    the STL containers with the exception that no elements may
    be inserted nor removed from the series.
*/

namespace Precision{
    template <
        typename NumberType,
        template <typename...> class Container = std::vector,
        typename GeneratorType = NumberType(std::size_t, const NumberType&)
    >
    class RecursiveSequence : Tag::Set{
        public:
        //Type Aliases
            using causal_type       = Sequence<
                                        NumberType,
                                        Container,
                                        GeneratorType
                                    >;
            using size_type         = typename causal_type::size_type;
            using value_type        = typename causal_type::value_type;
            using reference         = typename causal_type::reference;
            using const_reference   = typename causal_type::const_reference;
            using pointer           = typename causal_type::pointer;
            using const_pointer     = typename causal_type::const_pointer;
            using difference_type   = typename causal_type::difference_type;
            using container_type    = typename causal_type::container_type;
            using generator_type    = typename causal_type::generator_type;

        //Read-only
            bool empty()const
                {return m_series.empty();}

            size_type size()const
                {return m_series.empty();}

            const_reference operator[](size_type n)const;
            const_reference at(size_type n)const;
            size_type first_index()const;
            size_type last_index()const;
            const generator_type& generator()const;
            const_reference front()const;
            const_reference back()const;
                //Any ranges will include only [start, stop)
            RSEQ_INST_ subseries(size_type start, size_type stop=0)const;
            value_type sum(size_type start = 0, size_type stop = 0)const;
            value_type product(size_type start = 0, size_type stop = 0)const;
            short compare(const RSEQ_INST_&)const;
            size_type max_size()const;

        //Modifiers
            void pop_front(size_type = 1);
            void pop_back(size_type = 1);
            void push_front(const value_type&, size_type = 1);
            void push_back(const value_type&, size_type = 1);
            void generate(size_type = 1);
            void resize(size_type);
            void clear();
            void swap(RSEQ_INST_&);

            reference operator[](size_type n);
            void first_index(size_type);
            void last_index(size_type);
            void generator(const generator_type&);

        //Iterators
            using iterator          = typename causal_type::iterator;
            using const_iterator    = typename causal_type::const_iterator;
            using reverse_iterator  = typename causal_type::reverse_iterator;
            using const_reverse_iterator
                = typename causal_type::const_reverse_iterator;

            const_iterator begin()const;
            const_iterator end()const;
            const_reverse_iterator rbegin()const;
            const_reverse_iterator rend()const;
            const_iterator cbegin()const;
            const_iterator cend()const;
            const_reverse_iterator crbegin()const;
            const_reverse_iterator crend()const;

            const_iterator find(const_reference)const;
            const_iterator cfind(const_reference)const;

            iterator begin();
            iterator end();
            reverse_iterator rbegin();
            reverse_iterator rend();

            iterator find(const_reference);

        //Constructors and destructor
            RecursiveSequence(
                const generator_type&,
                size_type start = 0,
                size_type init_size = 0
            );
            template <typename Iter>
            RecursiveSequence(
                const Iter& start, const Iter& stop,
                const generator_type&,
                size_type start_index = 0
            );
            RecursiveSequence(const RSEQ_INST_&)            = default;
            RecursiveSequence(RSEQ_INST_&&)                 = default;
            RecursiveSequence& operator=(const RSEQ_INST_&) = default;
            RecursiveSequence& operator=(RSEQ_INST_&&)      = default;
            ~RecursiveSequence()                            = default;
        private:
            causal_type m_base;
    };
}

#undef RSEQ_INST_

#endif
